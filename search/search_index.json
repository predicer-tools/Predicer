{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"About us","text":""},{"location":"#welcome-to-predicers-user-guide","title":"Welcome to Predicer's User Guide!","text":""},{"location":"#contact-us","title":"Contact us","text":"<p>You can contact us by email: does-info@vtt.fi</p>"},{"location":"example_models/","title":"Example models","text":""},{"location":"example_models/#example-models-in-detail","title":"Example models in detail","text":""},{"location":"example_models/#introduction","title":"Introduction","text":"<p>This section contains a more detailed description of example models found in Predicer. The idea behind the example models is not to provide a detailed and correct ready-to-use model, but rather to explain concepts and ideas found in Predicer, and how it is implemented in the input data files. These concepts and ideas can then be used to build more complex models replicating real systems. It is recommended that this section is read while having the respective example model input data file for reference.</p> <p>Every aspect of every model is not discussed in detail, if concepts and ideas are described in previous models.</p>"},{"location":"example_models/#simple-building-model","title":"Simple building model","text":"<p>The input data file for the model can be found under \"/Predicer/input_data/simple_building_model.xlsx\". The simple building model is a model of a simplified building with direct electric heating with spot-based electricity pricing. The energy balance of the modelled building consists of three major elements; heat loss from inside the building to the ambient air, and an electric heater to maintain the temperature of the inside air within a comfortable range. In addition an electric powered domestic hot water (DHW) tank is modelled as a storage, with the use of DHW being represented by a timeseries. The aim of the model is to minimize the electricity costs for the electric heater and the DHW heater by using the storage capacities of the building and the DHW tank to time the use of electricity to the cheapest hours. This should be done while maintaining the temperature of the building at a comfortable level and ensuring that the hot water tank doesn't empty at any point during the day.</p> <p>A real building could of course be modelled more accurately, adding concepts such as heat losses through ventilation, overall electricity use, effect of solar radiation, dividing the building into smaller nodes, etc. </p> <p>The model horizon for the simple building model is 9.0 hours with the timesteps being 15 minutes, for a total of 36 timesteps. There are three scenarios in the model (s1, s2 and s3), and all of the data used in the model is randomly generated. </p>"},{"location":"example_models/#nodes-and-processes","title":"Nodes and processes","text":"<p>The model consists of five nodes: interiorair representing the air (and structures) inside the building, buildingenvelope representing the building components separating the inside from the outside, outsideair representing the ambient air, dhw representing the domestic hot water tank, and elc representing the local electricity grid the building is connected to. npe represents the electricity market from where electricity can be bought for a hourly varying price.</p> <p>There are two processes in the model: electricheater for converting electricity from the elc node to heat in the interiorair node, and dhw_heater converting electricity from the elc node to heat in the dhw node. Below is a simple schematic of the topology of the simple building model. </p> <pre><code>flowchart RL\nbuildingenvelope((buildingenvelope))\nnpe((npe))\noutside((outside))\nelectricitygrid((electricitygrid))\ninteriorair((interiorair))\ndhw((dhw))\ndhw_heater[dhw_heater]\nelectricheater[electricheater]\nelectricitygrid_npe_trade_process[electricitygrid_npe_trade_process]\nelectricitygrid --&gt; electricheater\nelectricheater --&gt; interiorair\nelectricitygrid --&gt; dhw_heater\ndhw_heater --&gt; dhw\nelectricitygrid --&gt; electricitygrid_npe_trade_process\nelectricitygrid_npe_trade_process --&gt; npe\nnpe --&gt; electricitygrid_npe_trade_process\nelectricitygrid_npe_trade_process --&gt; electricitygrid\ninteriorair -.-&gt; buildingenvelope\nbuildingenvelope -.-&gt; outside</code></pre>"},{"location":"example_models/#modelling-building-heat-loss","title":"Modelling building heat loss","text":"<p>The building heat loss is modelled as transfer of heat through the buildingenvelope, driven by the temperature difference between the interiorair and the outsideair nodes. The heat loss to the ambient air is modelled using the diffusion functionality found in Predicer. A diffusion flow can be defined between two nodes with states, with the states generally being modelled as temperature instead of energy.  The size of the flow between two nodes in a diffusion relation is simply the difference between the states multiplied with a user-defined coefficient c. </p> <p>P<sub>loss</sub> = c * (state<sub>1</sub> - state<sub>2</sub>)</p> <p>The unit of the heat transfer coefficient c in this model case would be kW/K. The value of the diffusion coefficient is chosen to be 0.25 (kW/K) between the interiorair and buildingenvelope nodes and 0.2 (kW/K) between the buildingenvelope and outside nodes. The diffusion coefficient is provided as a timeseries, and can vary between the timesteps even if in this example it is constant. One use case for a timeseries-dependent diffusion could be a wind forecast, with higher wind speeds resulting in a higher heat loss.</p> <p>In the example Excel file, this is done on the node_diffusion sheet, where data is defined for each scenario and timestep for both diffusion relations. </p> t interiorair,buildingenvelope,s1 buildingenvelope,outside,s1 2022-01-05T08:00:00 0.25 0.2 2022-01-05T08:15:00 0.25 0.2 <p>To be able to model heat loss, the buildingenvelope, interiorair and outside nodes are given states which represent the temperature in the respective nodes. This is done by setting the is_state and is_temp flags to True. </p> <p>Most of the flows in Predicer, such as process flows, diffusion flows, etc. are modelled as energy, not temperature. The conversion between energy and temperature for a state is defined in the T_E_conversion parameter. This parameter indicates how much energy is required to increase the temperature of the state by one (the unit depends on the model, in this case one Kelvin K). In the simple building model the energy is in the form of kW/kWh, and temperature in the form of K. The conversion rate is set to 0.5 (kWh/K) for the interiorair node and 1.0 (kWh/K) for the buildingenvelope node. If the heat losses were zero, this would mean that operating the electric heater at 1 kW for one hour would increase the temperature of the interiorair node by 2 K, which essentially would mean increasing the value of the storage (state) by 2. As the heat losses from the building are not expected to increase the temperature of the ambient air, the T_E_conversion parameter is set to 1 000 000 000 for the outside node. In the simple building model this means, that a cumulative heat flow of 10<sup>9</sup> kWh into the ambient air node is required to increase its storage state by 1 (K).</p> <p>The initial states of the interiorair, buildingenvelope and outside nodes are set to 292.15 K, 282.0 K and 269.5 K, respectively. The modelled system is approximately in balance on the first timestep when these values are used. </p> <p>As the heat loss in this model depends on the temperature difference between the building and the ambient air, it is important to be able to define the ambient air temperature properly. This can be done by setting the is_inflow flag of the outside node to True. This allows the hourly temperature changes of the ambient air to be given as an inflow timeseries to the node. So if the initial ambient temperature would be 263K, and the temperature for three first time steps would be 273K, 268K and 260K, the inflow timeseries to the ambient air node (outside) would be [+10, -5, -8] for the first three timesteps.</p> <p>As one of the objectives of this example model is to maintain a comfortable temperature inside the building, the boundaries of the comfortable temperature range must be defined. This can either be done using hard or soft boundaries. If hard boundaries are used, the temperature of the interiorair node is not allowed to go below or above the boundaries. This can be achieved either by setting the node parameters state_min and state_max to the desired temperature range, or by making user-defined gen_constraints with the is_setpoint flag set to false. </p> <p>Soft boundaries for the temperature range can be defined by making user-defined gen_constraints with the is_setpoint flag set to true. When a suitable cost (penalty parameter in the \"constraints\" sheet in the input data excel file) is set, the model can deviate from the given temperatue range, but this induces a cost for the model and is thus usually avoided. It is also possible to combine several layers of soft boundaries, with the cost of deviation increasing for each passed layer, and hard boundaries with soft boundaries, as long as the hard boundaries are less \"strict\" than the soft boundaries (e.g. hard boundary lower/upper limits of 15\u00b0C/27\u00b0C and soft boundery lower/upper limits of 19\u00b0C/24\u00b0C).</p> name operator is_setpoint penalty c_interiorair_up st 1 15 c_interiorair_down gt 1 15 <p>One set of soft boundaries are used in the example model, defined using the \"c_interiorair_up\" as upper limit and \"c_interiorair_down\" as lower limit gen_constraints. The operator for the constraints are \"st\" (smaller than) and \"gt\" (greater than), meaning that the value of the limited variable should be smaller than and greater than, respectively, than the value of the constraints. The parameter is_setpoint is set to true as this is a setpoint constraint, with the penalty parameter being set to 15 (\u20ac/K/h). The penalty is not a real cost, but rather a steering cost for getting the model to behave in an intended manner. The other part of the constraints are defined in the \"gen_constraint\" sheet in the input data excel. The limiting value for c_interiorair_up is set to 298.15K (25\u00b0C), and the limit for c_interiorair_down is 292.15K (19\u00b0C). </p> t c_interiorair_up,interiorair,s1 c_interiorair_down,interiorair,s1 2022-01-05T08:00:00 298,15 292,15 2022-01-05T08:15:00 298,15 292,15 ... ... ... <p>The state_min and state_max parameters for the interiorair, buildingenvelope and outside nodes are set to values that are outside the the system is expected to reach. As the inside temperature range is between 292K-298K, a suitable range for the interiorair state is 273K to 308K. For the outside and buildingenvelope nodes a minimum and maximum values for the states are chosen to be 238K and 308K. </p>"},{"location":"example_models/#modelling-the-domestic-hot-water-system","title":"Modelling the domestic hot water system","text":"<p>The idea behind modelling the DHW system is to use the DHW tank as a storage, to time the use of electricity to prepare the hot water to the time when the price of electricity is the lowest. This has to be done, while ensuring that the DHW never runs out. The storage is allowed to be empty momentarily, as long as there is enough to cover the demand at all times. </p> <p>The DHW system is modelled using a node dhw with a state (storage) and inflow (hot water use timeseries). The unit in dhw is thought to be kWh, to make it easier to model in this case. This means that the \"water\" in the DHW tank is represented by the amount of energy it would require to heat it from cold water, and the limits of the storage, as well as the inflow (use) of DHW uses this same unit. The storage losses of the DHW tank are not accounted for, as it is assumed that the heat is dissipated into the building, thus reducing the need to operate the electric space heater. The state_loss-proportional parameter is thus set to 0. </p> <p>The inflow data for the DHW system is randomly generated, with a small baseload and one or more larger spikes, representing 5-15 minute showers. The DHW demand can either be covered directly using the dhw heater, or by taking water from the hot water tank. The DHW demand is between 15 - 22 kWh over the modelled 9 hours, with the largest peak being 9.17 kWh over an timestep. This means that the dhw_heater (3 kW) is not enough to cover the demand at all timesteps. </p> <p>As Predicer doesn't consider what happens before or after the modelled time horizon, it is likely that the DHW tank would be empty after the last timestep, since any water left in the tank would be \"wasted\" from the perspective of the model. To amend this, a value for the water remaining in the tank can be defined. This value estimate is set to be the average hourly electricity price of the simple building model. This parameter is defined using the state_residual_value field in the input_data file on the nodes sheet.</p>"},{"location":"example_models/#simple-district-heating-system-model","title":"Simple district heating system model","text":"<p>The input data file for the model can be found under \"/Predicer/input_data/simple_dh_model.xlsx\". The simple district heating model is a model of a simple district heating system, operated by a single actor. The idea behind the system is to minimize the costs (or maximize the profits) while covering an hourly heat demand, and operating on an electricity spot market. The heat demand is defined as a time series, and the system has to cover the demand at all times. Several different heat generation units in combination with a heat day storage provides flexibility, which can be utilized to minimize the costs of covering the demand. The price of the provided heat is not defined (also 0), as is usual for local DH system modelling. The costs of the modelled system thus consist of fuel and operational costs for generating the required heat, and profits come from electricity sold to the spot market.</p> <p>The model only considers heat balances on a system production level, and building-specific balances are not considered. DH pressures, temperatures, losses, etc. are also not considered in the model. The modelled system is fictional, and the data used in the model is either fictional and/or randomly generated.</p>"},{"location":"example_models/#nodes-and-processes_1","title":"Nodes and processes","text":"<p>The modelled system consists of five nodes: ng representing a natural gas grid from where natural gas can be bought for a fixed price, elc representing a local electricity grid, heat representing a district heating grid, hp_source representing a natural heat source, such as seawater, and npe representing an electricity spot market where electticity can be bopught and sold for an hourly price. Additionally the node heat_storage represents a thermal energy storage connected to the district heating system. </p> <p>There are several process for generating heat in the system; elc_boiler converting electricity directly to heat, heat_pump_1 converting electricity and low-temperature heat from the hp_source node to heat in the heat node with a variable capacity, heat_pump_2 converting electricity to heat in the heat node with a variable efficiency, solar_collector producing heat based on a capacity factor time series, and ngchp representing a combined heat and power plant converting natural gas from the ng node to electricity and heat at a fixed ratio. Additionally, there is a process heat_sto_charge for transferring heat from the heat node to the heat_storage and heat_sto_discharge for transferring heat from the heat_storage to the heat node. The process elc_npe_trade_process is used to buy and sell electricity from the electricity spot market npe. </p> <p>Below is a simple flowchart of the modelled system, showing the connections between the nodes and processes in the modelled system. </p> <pre><code>flowchart TD\nnpe((npe))\nheat((heat))\nng((ng))\nhp_source((hp_source))\nheat_storage((heat_storage))\nelc((elc))\nelc_boiler[elc_boiler]\nsolar_collector[solar_collector]\nelc_npe_trade_process[elc_npe_trade_process]\nngchp[ngchp]\nheat_sto_charge[heat_sto_charge]\nheat_pump_1[heat_pump_1]\nheat_pump_2[heat_pump_2]\nheat_sto_discharge[heat_sto_discharge]\nng --&gt; ngchp\nngchp --&gt; elc\nngchp --&gt; heat\nhp_source --&gt; heat_pump_1\nelc --&gt; heat_pump_1\nheat_pump_1 --&gt; heat\nelc --&gt; heat_pump_2\nheat_pump_2 --&gt; heat\nheat --&gt; heat_sto_charge\nheat_sto_charge --&gt; heat_storage\nheat_storage --&gt; heat_sto_discharge\nheat_sto_discharge --&gt; heat\nelc --&gt; elc_boiler\nelc_boiler --&gt; heat\nsolar_collector --&gt; heat\nelc --&gt; elc_npe_trade_process\nelc_npe_trade_process --&gt; npe\nnpe --&gt; elc_npe_trade_process\nelc_npe_trade_process --&gt; elc</code></pre> <p>In the model there are various costs linked to power and heat generation which should be taken into consideration. These costs include fuel costs (natural gas, electricity), electricity transmission costs, carbon emission permits, as well as emission taxes for carbon and electricity. The fuel cost of natural gas is defined as a timeseries on the price sheet in the input data, with a value of 25.0 (\u20ac/MWh) for every hour. The cost of electricity, both when buying and selling is defined as a timeseries in the market_prices sheet in the input data. The prices are randomly generated, and vary between 2.13-85.38 (\u20ac/MWh), with an average price of 42.92 (\u20ac/MWh). </p> <p>The sum of the carbon emission permits and carbon tax amount to 22.0 (\u20ac) per MWh of natural gas used. As these costs depend on the use of natural gas from the ng node, the VOM (variable operation and maintenance) cost of the natural gas flow for the ngchp process in the process_topologies sheet is set to 22.0. This causes a cost of 22.0 for each unit (MWh) of ng that is used by the ngchp process. In this example model case these costs could also have been directly added to the price of natural gas, as the ngchp process is the sole consumer of natural gas. Another way to implement carbon permits or taxes (\u20ac/ton) would be to add a \"emissions\" flow to relevant processes and to add the costs to the VOM of this flow. To ensure this works properly, a gen_constraint has to be created to fix the size of the emission flow proportional to the size of the natural gas flow into the process. Additionally, the efficiency of the process has to be adjusted to include the emissions. A third way would be to create a commodity node carbon_permits_and_taxes, from where there would be a flow to a process using natural gas. In this case a gen_constraint fixing the ratio between natural gas and \"emissions\" would be needed as well. The emission costs can be set as the price of the commodity node. </p> <p>The sum of electricity tax and distribution costs is assumed to be 15.0 (\u20ac/MWh), and is added to each topology where electricity is consumed, except when buying from the market node. In this model this means the elc flows of the heat pumps and the elc flow of the elc_boiler. A summary of the relevant production costs for processes and flows is visualized in the table below. </p> Process flow Fuel costs Taxes + Carbon permits ngchp, ng 25.0 22.0 ngchp, elc 0.0 0.0 ngchp, heat 0.0 0.0 heat_pump_1, elc 2.13 - 85.38 15.0 heat_pump_1, hp_source 0.0 0.0 heat_pump_1, heat 0.0 0.0 heat_pump_2, elc 2.13 - 85.38 15.0 heat_pump_2, heat 0.0 0.0 heat_sto_charge, heat 0.0 0.0 heat_sto_charge, heat_storage 0.0 0.0 heat_sto_discharge, heat_storage 0.0 0.0 heat_sto_discharge, heat 0.0 0.0 solar_collector, heat 0.0 0.0 elc_boiler, elc 2.13 - 85.38 15.0 elc_boiler, heat 0.0 0.0"},{"location":"example_models/#scenario-and-market-definition","title":"Scenario and market definition","text":"<p>Scenarios in Predicer are user-defined possible futures the system and environment around the system can take, with different values for forecasted values, such as prices, weather, supply and demand, etc., but different scenarios can have identical values in one or several timesteps as well. These scenarios are separate from each other, with for example the weather forecast (solar/wind production, heat demand, etc.) ideally correlating with market price forecasts within the same scenario. In this model there are three scenarios: s1, s2 and s3. The scenarios are defined on the scenarios sheet in the input data file. The probability of these scenarios is 0.3, 0.4 and 0.3, respectively, and is used for weighting the scenario properly in the optimization. </p> scenario probability s1 0.3 s2 0.4 s3 0.3 <p>This example model has one defined market, npe which represents an electricity spot market where electricity can be bought and sold for prices and volumes that are determined the day before. Running Predicer produces a bidding curve for each defined market. This bidding curve consists of a group of price-volume pairs, and essentially indicates how much should be bought or sold from a market, if the price were x. The market prices for different scenarios for each timestep is used as a basis for the bidding curves. This means, that the price points for a specific hour on the bidding curve are defined using the market prices in the different scenarios. As a result, the number of price points on the bidding curves depends on the number of scenarios, and if the scenarios have unique values or not.</p> <p>The market npe is defined on the markets sheet in the input data file. The type parameter is defined to \"energy\" (as oppposed to \"reserve\" for reserve markets), and the linked node is elc. The parameters processgroup, direction, realisation and reserve_type are only used for reserve markets, and have been given filler values in this example. The market npe has a bidding functionality, but is not limited. The parameter is_bid is thus set to true, while the parameters is_limited, min_bid and max_bid are set to zero. There is no fee for bidding, so fee is also set to zero. </p> market type node processgroup direction realisation reserve_type is_bid is_limited min_bid max_bid fee npe energy elc p1 none 0 none 1 0 0 0 0 <p>The price forecasts for the markets in the model are defined on the market_prices sheet in the input data file. These are in the form of timeseries, defined for every scenario, for every market. A part of the market_prices table is visualized below. When an energy market is defined, the balance markets npe_up and npe_down are automatically created. The model can buy (up) or sell (down) from these markets to adjust the system energy balance if needed. </p> t npe,s1 npe,s2 npe,s3 16.4.2024 0:00 16,43 24,25 17,77 16.4.2024 1:00 7,65 22,58 19,13 16.4.2024 2:00 2,13 24,53 20,42 ... ... ... ... <p>The prices for the balance markets are defined in the balance_prices sheet in the input data file. As the user-defined market npe and the balance markets npe_up and npe_down are connected to the same node (elc), the model can buy from one market and sell to the other. This causes the model to be unbounded unless buying from one market and selling to another is disadvantageous. In this example this is done by setting the price of npe_up to 0.01 more than the price for npe, and *npe_down to 0.01 less than the corresponding price given for npe. Parts of the table defined in the balance_prices sheet is visualized below. </p> t npe,up,s1 npe,up,s2 npe,up,s3 npe,dw,s1 npe,dw,s2 npe,dw,s3 16.4.2024 0:00 16,44 24,26 17,78 16,42 24,24 17,76 16.4.2024 1:00 7,66 22,59 19,14 7,64 22,57 19,12 16.4.2024 2:00 2,14 24,54 20,43 2,12 24,52 20,41 ... ... ... ... ... ... ..."},{"location":"example_models/#modelling-the-chp-unit","title":"Modelling the CHP unit","text":"<p>The combined heat and power process ngchp converts natural gas from the ng node to electricity to the elc node and heat to the heat node. In reality a natural gas-based CHP plant would consist of a steam boiler, steam turbine, turbine bypass, etc. In this case the whole plant is modelled as a single process with fuel in to the process and electricity and heat out of the process. The heat rate of the process is set to be constant at all loads, with the amount of generated heat being 3 times the amount of generated electricity. The process ngchp is modelled with the ng flow in and with the elc and heat flows out. So called user constraints, or in Predicer terms gen_constraints, are used to define the heat rate. Without user constraints Predicer would be able to adjust the electric and heat flows freely, as long as efficiency, online and capacity boundaries are fulfilled. </p> <p>The user constraints are defined in the constraint and gen_constraint sheets in the input data file. The name, type and operator of the constraint is defined on the constraint sheet. The user constraint ngchp_c1 has the operator eq, meaning \"equal\", and it is not a setpoint constraint. How the constraint ngchp_c1 is defined on the constraint sheet is shown in the table below. </p> name operator is_setpoint penalty ngchp_c1 eq 0 0 <p>User constraints consist of a sum of variables multiplied with coefficients, being set equal to a constant. The names, types and coefficients of the variables limited by the user constraints are defined on on the gen_constraint sheet. In this example case the heat flow variable should be set to be three times larger than the electricity flow variable, which can be written as:</p> <p>v_flow[heat] = 3 * v_flow[elc]</p> <p>Which can be written as</p> <p>v_flow[heat] - 3 * v_flow[elc] = 0</p> <p>The coefficients for the heat and electricity flow variables should thus be 1 and -2, respecitvely, and the constant should be zero. Below is a part of the gen_constraints sheet table, where the variables, coefficients and constant are defined. The types of the variables depends on the column names, and in the case of flow variables is of the form constraint_name,process,flow,scenario. As such the column names are \"ngchp_c1,ngchp,elc,s1\" and \"ngchp_c1,ngchp,heat,s1\". Additionally, the constant value of the constraint is required, and is defined with a column namenotation of constraint_name,scenario. As the heat rate is constant, and same in all scenarios, the values must be defined for every timestep in all scenarios. </p> t ngchp_c1,ngchp,elc,s1 ngchp_c1,ngchp,heat,s1 ngchp_c1,s1 16.4.2024 0:00 -2 1 0 16.4.2024 1:00 -2 1 0 ... ... ... ... <p>In this model the heat rate is set to a constant value, but it would be possible to have a varying heat rate. This could be done by making two user constraints, one defining the lower bound of the electricity-heat ratio, and one defining the upper bound of the ratio. Assuming the heat output should be between 2.5 and 3.5 times the electrical output, the constraint could be formulated as: </p> <p>v_flow[heat] &gt;= 1.5 * v_flow[elc]</p> <p>v_flow[heat] &lt;= 2.5 * v_flow[elc]</p> <p>Which can be written as</p> <p>v_flow[heat] - 1.5 * v_flow[elc] &gt;= 0</p> <p>v_flow[heat] - 2.5 * v_flow[elc] &lt;= 0</p>"},{"location":"example_models/#modelling-the-heat-pumps","title":"Modelling the heat pumps","text":"<p>There are two heat pump processes, heat_pump_1 and heat_pump_2, in this example model. Both of these processes convert electricity from the elc node to heat in the heat node. Additionally heat_pump_1 is connected to the commodity node hp_source, from where lower-grade heat can be obtained from free, but at a limited availability. The coefficient of power (COP) of a heat pump depends on many factors, one of which is the temperature of the used heat source. As the temperature (and thus COP) and availability of some natural heat sources typically fluctuate between seasons or even days, the operational limits of heat pump can be defined using timeseries. In this example there are two heat pumps with similar parameters (capacity, cost, etc). The operation of the heat pumps is affected by the price of electricity, the efficiency, and the amount of heat available from the node hp_source. The heat production of heat_pump_1 is limited by the availability of heat from the hp_source node, while the production for the process heat_pump_2 depends on a timeseries-dependent efficiency.</p> <p>The amount of heat from the hp_source available to the heat_pump_1 process is limited with a timeseries, setting an upper limit for the flow between the hp_source node and the heat_pump_1 process. This timeseries is defined on the cap_ts sheet in the example input data. Below is a part of the table found in the cap_ts sheet in the input data file. It is assumed, that the efficiency of heat_pump_1 is constant at 2.0, meaning \u00bd of the generated heat comes from the electricity, and \u00bd comes from the heat source. A value of 1,57 (MW) for available heat would mean, that the amount of electricity is equal (1.57 MW) and the total heat output would be 3.14 MW. </p> t heat_pump,hp_source,s1 heat_pump,hp_source,s2 heat_pump,hp_source,s3 16.4.2024 0:00 1,57 2,35 2,50 16.4.2024 1:00 1,62 2,45 2,55 16.4.2024 2:00 1,62 2,55 2,45 ... ... ... ... <p>Like the ngchp process, the ratio of the incoming flows should be fixed. This ratio is fixed using the user constraints, like the ngchp process. The coefficients for the variables should be -1.0 and 1.0, with the constant being 0.0. </p> t hp1_c1,heat_pump_1,elc,s1 hp1_c1,heat_pump_1,hp_source,s1 hp1_c1,s1 16.4.2024 0:00 -1 1 0 16.4.2024 1:00 -1 1 0 16.4.2024 2:00 -1 1 0 ... ... ... ... <p>The efficiency timeseries for the heat_pump_2 process is defined on the eff_ts sheet in the input data. The given timeseries limits the total efficiency of the process for every timestep, meaning flows_in * eff = flows_out. The heatpump has one flow in (elc) and one flow out (heat). Below is a part of the defined data in the eff_ts sheet in the input data file. An efficiency of 1.95 would in the case of the heat_pump_2 process mean that the amount of heat provided to the heat node at time t is 1.95 times the electric power of the heat pump at time t, meaning 1.0 MW of electricity and 0.95 MW of heat (not modelled for heat_pump_2) would be required for a heat output of 1.95 MW. Because there is only one flow in and one flow out, there is no need to create gen_constraints for heat_pump_2.</p> t heat_pump_2,s1 heat_pump_2,s2 heat_pump_2,s3 16.4.2024 0:00 1,95 2,1 1,75 16.4.2024 1:00 1,83 2,04 1,64 16.4.2024 2:00 1,93 2,14 1,57 ... ... ... ..."},{"location":"example_models/#modelling-the-solar-collector","title":"Modelling the solar collector","text":"<p>The solar collector process solar_collector in this model is modelled as a capacity factor (cf) process. In contrast to other process types, cf processes do not have a source node going into the process. Instead, the process is modelled using a capacity factor timeseries. This means that the process has a maximum output, and a hourly capacity factor (cf) timeseries defining what percentage of this output can be used. This cf timeseries is defined on the cg sheet in the input data file.</p> t solar_collector,s1 solar_collector,s2 solar_collector,s3 16.4.2024 0:00 1 0,63 0,02 16.4.2024 1:00 0,96 0,56 0,0 16.4.2024 2:00 0,97 0,55 0,09 ... ... ... ... <p>The maximum capacity of the solar collector is set to 3.0 (MW). The is_fixed flag in the processes sheet is set to false, meaning that the cf timeseries sets an upper limit for the production of the cf process. If is_fixed would be set to true, then the output of the process would be fixed by the capacity factor timeseries. </p> <p>In this example this means, that if the value capacity factor timeseries value for a certain hour would be 1, then the output of the solar_collector process would be between 0.0 (MW) and 3.0 (MW). If the cf value would be 0.3, the output would be 0-0.9 (MW). </p>"},{"location":"example_models/#modelling-the-heat-storage","title":"Modelling the heat storage","text":"<p>The simple district heating model contains a daily heat storage, which can be used to balance the system and offer flexibility between hours. The storage is defined in the node heat_storage, and it is connected to the heat node via the processes heat_sto_charge and heat_sto_discharge. The capacity of the storage is set to 10.0 (MWh), with the maximum flows in and out of the storage each being 3.0 (MW). As the system heat demand varies between 7-15 (MW), the storage alone cannot be used to generate heat into the system. The storage losses are 0.001 of the storage value per hour, and the starting value of the storage is set to 0.0. </p> <p>Optimization models commonly empty storages by the end of the model horizon, as any storage content is \"wasted\" from the model perspective. To prevent this, a value for heat remaining in the storage at the end of the model horizon is defined. The chosen value should represent the expected costs of heat production in the \"next\" horizon.</p>"},{"location":"example_models/#two-stage-model","title":"Two stage model","text":"<p>The two stage dh model is an extension of the simple district heating model described above. The model is defined in the \"two_stage_dh_model.xlsx\" input data file. The extension consists of a simple two stage modelling implementation, with a first stage where the price of the market npe and all other timeseries parameters are known and identical for all scenarios (s1, s2, s3). After the common start, the scenarios branch out into separate forecasts in the second stage. The lengths of the first and second stages are 12 timesteps (12 hours) each. The two stage approach is defined in the setup sheet, with setting the common_timesteps parameter to 12, and the common_scenario_name parameter to \"ALL\". This leads to all variable indices to have the scenario name ALL for the first 12 timesteps, instead of the standard scenario names. </p> <p>All of the scenario-dependent timeseries parameters are set to be identical between the scenarios for each timestep for the first 12 timesteps. In this case this means the inflow, cf, (price), market_prices, balance_prices, eff_ts, cap_ts, and constraint timeseries. After the model has been optimized, the values for the variables for the first 12 timesteps are the same in all scenarios, after which they start to branch out. </p>"},{"location":"example_models/#simple-hydropower-river-system","title":"Simple hydropower river system","text":"<p>The input data file for the example model can be found under \"simple_hydropower_river_system.xlsx\". This example model consists of a hydropower river system with five hydropower plants connected by a river. Each hydropower plant contains a reservoir, where water can be stored for optimal use timing. Each reservoir has a inflow of water from smaller rivers or rainfall Each hydropower plant also contains a turbine by-pass, which can be used to release water from the reservoir to the river without producing electricity. The model contains a delay between the hydropower plant, meaning it takes a while for the released water to reach the next plant. </p> <p>The goal of the model is to maimize the profits on the linked electricity markets by optimizing the use of the water in the reservoirs as well as possible. The system is constrained by minimum and maximum flow requirements for the river, as well as minimum and maximum water levels in the reservoirs. The model contains three scenarios \"dry\", \"normal\" and \"wet\", with differing electricity market prices and inflow to the reservoirs. The scenario \"dry\" contains a lower inflow into the reservoirs and resulting higher electricity prices. The scenario \"wet\" containts a higher inflow into the reservoirs and lower electricity prices, while the scenario \"medium\" lies somewhere in between \"dry\" and *\"wet\"*in regards to inflow and electricity prices. </p> <p>The depicted system is fictional, and all timeseries data (inflows, market prices, etc.) is randomly generated, with some modifications. The time horizon for the model is 30 days, with the first two days being modelled in higher resolution with one hour timesteps, the following two days modelled with 4 hour timesteps, and the rest being modelled with one day timesteps. </p>"},{"location":"example_models/#nodes-and-processes_2","title":"Nodes and processes","text":"<p>There are five hydropower plants (processes) in the model hydro1, hydro2, hydro3, hydro4 and hydro5, representing hydropower turbines. All of these processes have a linked node; res1, res2, res3, res4 and res5, respectively. Each plant also has a linked spill process hydro1_spill, hydro2_spill, hydro3_spill, hydro4_spill, and hydro5_spill, which can be used to release water from the linked reservoir without producing electricity. A simple schematic of the river system can be seen in the figure below. The reservoirs linked to the processes hydro1 and hydro2 do not have an \"upstream\" connection, and the processes both connect with the reservoir linked with hydro3. The process hydro3 is upstream of  hydro4, which is upstream of hydro5. The process hydro5 doesn't have a downstream node, and it could be thought that this is where the river system flows out to the sea. The modellled system also has an electricity node elc, which is linked to electricity energy and reserve markets. Each of the hydropower plants has a connection to the elc node. </p> <pre><code>flowchart TD\n\n</code></pre> <p>The reservoir nodes (both inflows and flows) are modelled as water (m<sup>3</sup>). As the flows are large, the unit of one water is assumed to be 1000 m<sup>3</sup> instead of 1 m<sup>3</sup>. This reduces scaling issues in the model as well. The amount of energy available in the water can be calculated using the potential energy of the water, and assuming some losses in the conversion process. The process electrical generation ber unit of water (1000 m<sup>3</sup>), the corresponding process (electrical) efficiency p, as well as reservoir and flow limitations are shown in the table below. All the water-related numbers are per 1000 m<sup>3</sup>.</p> Process Elc per water Efficiency Reservoir max Reservoir min Min flow Max flow hydro1 0.0818 MWh 0.073 2000 800 40 300 hydro2 0.1227 MWh 0.110 2000 800 40 300 hydro3 0.1092 MWh 0.098 2000 800 40 300 hydro4 0.0956 MWh 0.086 2000 800 40 300 hydro5 0.0437 MWh 0.039 2000 800 40 300 <ul> <li>river inflow</li> <li>delays</li> <li>reservoirs, spill, etc</li> </ul>"},{"location":"example_models/#large-convenience-store","title":"Large convenience store","text":"<ul> <li>Heat pumps</li> <li>Solar panels</li> <li>Cold shelves as storage, building as storage</li> <li>Either DH or local heat source (GSHP?)</li> <li>Solar panels/collectors</li> </ul>"},{"location":"example_models/#simple-hydropower-river-system_1","title":"Simple hydropower river system","text":"<ul> <li>Delay between plants?</li> <li>Variable time control?</li> </ul>"},{"location":"example_models/#electric-storage-producing-reserve","title":"Electric storage producing reserve","text":"<ul> <li>Solar cells + storage acting on spot + some reserve market. </li> </ul>"},{"location":"example_models/#rolling-model","title":"Rolling model","text":"<ul> <li>Rolling model for one year. </li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#getting-started","title":"Getting Started","text":""},{"location":"getting_started/#how-to-install","title":"How to install","text":"<ul> <li>Clone the project to your computer using git.</li> <li>Make sure that the main branch is activated.</li> <li>Open a julia REPL. It is recommended to use a IDE such as VSCode or Atom, as the results from the model are currently not saved in a separate file.</li> <li> <p>Navigate to .\\Predicer using the <code>cd</code> command.</p> <pre><code>julia&gt; cd(\"./Predicer)\n</code></pre> </li> <li> <p>type <code>]</code> to open the package manager in julia, and type <code>activate .</code> to activate the local Julia environment.</p> <pre><code>(Predicer) pkg&gt; activate .\n</code></pre> </li> <li> <p>Press backspace to exit the package manager</p> </li> <li> <p>Type <code>using Pkg</code> followed by <code>Pkg.instantiate()</code> to install the required packages. This can take a while.</p> <pre><code>julia&gt; using Pkg\njulia&gt; Pkg.instantiate()\n</code></pre> </li> <li> <p>Finally type <code>using Predicer</code> to use the package.</p> </li> </ul>"},{"location":"getting_started/#how-to-use","title":"How to use","text":"<ul> <li>Navigate to the local folder containing the Predicer package.</li> <li> <p>type <code>]</code> to open the package manager in julia, and type <code>activate .</code> to activate the local Julia environment.</p> <pre><code>(Predicer) pkg&gt; activate .\n</code></pre> </li> <li> <p>Press backspace to exit the package manager</p> </li> <li> <p>Type <code>using Predicer</code> to use the package.</p> <pre><code>julia&gt; using Predicer\n</code></pre> </li> <li> <p>To generate a model based on a input data file (in the example an Excel file located under <code>Predicer/input_data/</code>) use the <code>Predicer.generate_model(fpath)</code> function, where the parameter 'fpath' is the path to the input data file. The 'generate_model()' function imports the input data from the defined location, and build a model around it. The function returns two values, a \"model contents\" (mc) dictionary containing the built optimization model, as well as used expressions, indices and constraints for debugging. The other return value is the input data on which the optimization model is built on. </p> <pre><code>julia&gt; mc, input_data = Predicer.generate_model(fpath)\n</code></pre> </li> <li> <p>Or if using the example input data file <code>Predicer/input_data/input_data.xlsx</code></p> <pre><code>julia&gt; mc, input_data = Predicer.generate_model(\"input_data/input_data.xlsx\")\n</code></pre> </li> <li> <p><code>Predicer.solve_model(mc)</code> optimizes the model, and shows the solver output.</p> <pre><code>julia&gt; Predicer.solve_model(mc)\n</code></pre> </li> <li> <p>After the model has been successfully optimized, the results of the variables in the model can be obtained using the <code>Predicer.get_result_dataframe()</code> or <code>Predicer.get_all_result_dataframes()</code> functions. Predicer.get_all_result_dataframes returns a dictionary with the variable names as keys, and Dataframes containing the results for those keys as values. </p> <pre><code>julia&gt; result_dataframes = Predicer.get_all_result_dataframes(mc, input_data)\njulia&gt; Predicer.get_all_result_dataframes(mc, input_data)\n        Dict{Any, Any} with 21 entries:\n        \"vq_state_dw\"      =&gt; 24\u00d713 DataFrame\u2026\n        \"v_set_up\"         =&gt; 24\u00d71 DataFrame\u2026 \n        \"v_flow_bal\"       =&gt; 24\u00d77 DataFrame\u2026 \n        \"v_bid\"            =&gt; 24\u00d74 DataFrame\u2026 \n        \"v_node_delay\"     =&gt; 24\u00d71 DataFrame\u2026 \n        \"v_block\"          =&gt; 0\u00d70 DataFrame   \n        \"v_res_final\"      =&gt; 24\u00d710 DataFrame\u2026\n        \"v_set_down\"       =&gt; 24\u00d71 DataFrame\u2026 \n        \"vq_ramp_dw\"       =&gt; 24\u00d722 DataFrame\u2026\n        \"v_start\"          =&gt; 24\u00d74 DataFrame\u2026 \n        \"vq_state_up\"      =&gt; 24\u00d713 DataFrame\u2026\n        \"vq_ramp_up\"       =&gt; 24\u00d722 DataFrame\u2026\n        \"v_setpoint\"       =&gt; 24\u00d71 DataFrame\u2026 \n        \"v_node_diffusion\" =&gt; 24\u00d71 DataFrame\u2026 \n        \"v_online\"         =&gt; 24\u00d74 DataFrame\u2026 \n        \"v_stop\"           =&gt; 24\u00d74 DataFrame\u2026 \n        \"v_reserve\"        =&gt; 24\u00d737 DataFrame\u2026\n        \"v_flow\"           =&gt; 24\u00d737 DataFrame\u2026\n        \"v_load\"           =&gt; 24\u00d710 DataFrame\u2026\n        \"v_reserve_online\" =&gt; 24\u00d77 DataFrame\u2026 \n        \"v_state\"          =&gt; 24\u00d77 DataFrame\u2026\n</code></pre> </li> <li> <p>For more specific analysis, <code>Predicer.get_result_dataframe()</code> returns a DataFrame for a specific variable type, with the option to specify the node or process as well as the scenario. Below an example where the values for the <code>v_flow</code> variable for the <code>hp1</code> process is obtained. The column names show which flow the value is for, with the notation being <code>processname _ from node _ to node _ scenario</code>; <code>hp1_elc_hp1_s1</code> is for the electricity consumption of the heat pump process, and <code>hp1_hp1_dh_s1</code> is for the heat production to the district heating node (dh). The types of the available variables can be found in the function documentation or in the example above. </p> <pre><code>julia&gt; Predicer.get_result_dataframe(mc, input_data, \"v_flow\", \"hp1\",  \"s1\")\n        24\u00d73 DataFrame\n        Row \u2502 t                          hp1_elc_hp1_s1  hp1_hp1_dh_s1 \n        \u2502 String                     Float64         Float64       \n        \u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n        1 \u2502 2022-04-20T00:00:00+00:00       0.5              1.5\n        2 \u2502 2022-04-20T01:00:00+00:00       0.0              0.0\n        3 \u2502 2022-04-20T02:00:00+00:00       0.0              0.0\n        \u22ee  \u2502             \u22ee                    \u22ee               \u22ee\n        22 \u2502 2022-04-20T21:00:00+00:00       0.970055         3.39519\n        23 \u2502 2022-04-20T22:00:00+00:00       1.42857          5.0\n        24 \u2502 2022-04-20T23:00:00+00:00       1.71429          6.0\n</code></pre> </li> <li> <p>The modelled costs can be retrieved using the <code>get_costs_dataframe()</code> function. This includes realised costs, controlling costs and dummy costs. The realised costs include costs of used fuels and commodities, operational costs, market costs/profits, etc. The controlling costs include the value of the storage at the end of the optimization horizon, deviation from setpoints, etc. Dummy costs include costs for dummy or slack variables, which are used to ensure feasibility during optimization. </p> <pre><code>julia&gt; costs_df = Predicer.get_costs_dataframe(mc, input_data)\n</code></pre> </li> <li> <p>The DataFrames obtained from the results can be exported to an xlsx-file using the <code>dfs_to_xlsx()</code> function. The Dataframes can be passed to the function either in a dictionary with the name of the dataframe as the keys, or as a single DataFrame. The other parameters passed to the function are <code>output_path</code>, which is the path to where the file is to be saved, and <code>fname</code> is the name of the exported file. An suffix with the date is automatically added to the end of the filename. </p> <pre><code>julia&gt; Predicer.dfs_to_xlsx(df, output_path, fname)\n</code></pre> </li> <li> <p>The resulting bid matrix can be exported to a .xlsx file under <code>Predicer/results</code> by using the <code>Predicer.write_bid_matrix()</code> function</p> <pre><code>julia&gt; Predicer.write_bid_matrix(mc, input_data)\n</code></pre> </li> </ul>"},{"location":"getting_started/#example-model","title":"Example model","text":"<p>A simple example model simple, imaginary energy system is documented here. The input data file of the example model can be found under /input_data/example_model.xlsx. The system contains natural gas, electricity and heat, and electricity and electricity reserve products are sold on an external market m. The example model contains two possible scenarios for input data, s1 and s2, with equal probabilities of occurring (0.5). The data used for prices, heat demand, capacity factors, etc. is randomly generated. </p>"},{"location":"getting_started/#nodes","title":"Nodes","text":"<p>The modelled system consists of three main nodes: ng, symbolizing a node containing natural gas, elc symbolizing a node containing electricity, and heat, a node containing heat, such as a district heating system. The ng node is a commodity node, from which natural gas can be bought at a price defined in the price sheet. The heat node has a negative inflow added to it, which can be seen as a heat demand in the system. The elc node is connected to a market node m, npe, from which electricity can be bought or sold. </p>"},{"location":"getting_started/#processes","title":"Processes","text":"<p>Processes are used to convert or transfer energy between nodes in the modelled system. The process windturb symbolizes a wind turbine producing electricity to the elc node. The production of windturb is limited by a capacity factor time series, defined in the cf sheet. The process ngchp converts natural gas from the ng node into electricity to the elc node and heat to the heat node at a fixed ratio, which is defined in the constraint and gen_constraint sheets. The heatpump unit convert electricity from the elc node into heat in the heat node. When the market m is defined, a process for trading between elc and m is automatically generated. </p> <p>The constraint to define the operation of the ngchp process is setup in the constraints and gen_constraint sheets. The flat efficiency of the ngchp process is set to 0.9, including both heat and power. The maximum capacity of the natural gas input is set to 10, the heat is 6, and the electricity is 3. ngchp should produce electricity and heat at a 1:2 ratio. To achieve this, constraint called ngchp_c1 is defined in the sheet constraints.</p> <p>The reserve products res_up and res_down are sold in the elc node. The processes ngchp and heatpump are used to offer reserve capacity. </p> <p> Basic structure of the example model.</p> name operator is_setpoint penalty ngchp_c1 eq 0 0 <p>Further, the factors for the constraint are defined in the gen_constraint sheet. The operator of the created constraint is eq, meaning equal.  The sum of the factors (the process branches elc and heat multiplied by given constants) and a given constant should equal 0. With a 1:2 ratio of electricity and heat production, the constants given to the process flows should be -2 and 1, or 2 and -1, for electricity and heat respectively. This can be seen in the table below, where the factors and constraints are defined for s1. The factors have to be defined again for s2.</p> t ngchp_c1,ngchp,elc,s1 ngchp_c1,ngchp,heat,s1 ngchp_c1,s1 t1 -2 1 0 t2 -2 1 0 tn -2 1 0"},{"location":"input_data/","title":"Building your model","text":""},{"location":"input_data/#input-data-description","title":"Input data description","text":"<p>The basic parameters and usage of the excel-format input data are described here. The input data has to be given to Predicer in a specific form, and the excel-format input data files are not a requirement. Excel has been used during development, since they were considered more convenient than databases or other forms of data structures.</p>"},{"location":"input_data/#setup","title":"setup","text":"<p>The setup sheet is used to define specific parameters used to define the functionalities of the model. The parameters defined in this sheet often override other information, for example if use_reserves is set to 0 (false), no reserve functionalities will be used in the model even if relevant structures are defined in other parts of the input data. This enables quick testing with or without certain features without needing to change large amounts of data or needing to use separate input data files. </p> Parameter Type Description use_market_bids Bool Flag indicating whether market bids are used in the model use_reserves Bool Flag indicating whether reserves are used in the model. If set to false, no reserve functionalities are used. use_reserve_realisation Bool Indicates whether reserves can be realised. If set to false, no realisation occurs. use_node_dummy_variables Bool Indicates if dummy variables should be used in the node balance equations. use_ramp_dummy_variables Bool Indicates if dummy variables should be used in the ramp balance equations. common_timesteps Int Indicates the length of a common start, where the parameters and variable values are equal across all scenarios. Default is 0. common_scenario_name String Name of the common start scenario, if it is used."},{"location":"input_data/#nodes","title":"nodes","text":"<p>Nodes are fundamental building blocks in Predicer, along with Processes.</p> Parameter Type Description node String Name of the node is_commodity Bool Indicates if the node is a commodity node is_state Bool Indicates if the node has a state (storage) is_res Bool Indicates if the node is involved in reserve markets is_market Bool Indicates if the node is a market node is_inflow Bool Indicates if the node has an inflow state_max Float Storage state capacity (if node has a state) state_min Float Storage state minimum level (if node has a state) in_max Float Storage state charge capacity out_max Float Storage state discharge capacity initial_state Float Initial state of the storage state_loss_proportional Float Hourly storage loss relative to the state of the storage scenario_independent_state Bool If true, forces the state variable to be equal in all scenarios is_temp Bool Flag indicating whether the state of the node models temperature T_E_conversion Float Conversion coefficient from temperature to energy (kWh/K) residual_value Float Value of the storage contents at the end of the time range"},{"location":"input_data/#processes","title":"processes","text":"<p>Processes are fundamental building blocks in Predicer, along with Nodes. They are used to convert or transfer electricity or heat, or etc. between nodes in the modelled system.</p> Parameter Type Description process String Name of the process is_cf Bool Indicates if the process is limited by a capacity factor time series is_cf_fix Bool Indicates if the process has to match the capacity factor time series is_online Bool Indicates if the process is an online/offline unit is_res Bool Indicates if the process participates in reserve markets conversion Integer Indicates the type of the process. 1 = unit based process, 2 = transfer process, 3 = market process eff Float Process efficiency (total output / total input) load_min Float Minimum load of the process as a fraction of total capacity. Only for online processes load_max Float Maximum load of the process as a fraction of total capacity. Only for online processes start_cost Float Cost of starting the unit, only for online processes. min_online Float Minimum time the process has to be online after start up min_offline Float Minimum time the process has to be offline during shut down max_online Float Maximum time the process can be online max_offline Float Maximum time the process can be offline scenario_independent_online Bool if true, forces the online variable of the process to be equal in all scenarios initial_state Bool Initial state of the online unit (0 = offline, 1 = online)"},{"location":"input_data/#groups","title":"groups","text":"<p>The user can define groups of either nodes or processes. Groups are used to define which processes or which nodes can for example participate in the realisation of a reserve. Group membership is defined row by row, with the first column being the type of the group, which is either node or process. The second column is the name of the entit (either a node or a process) which is to be part of the group named in the third column. A group can only contain entities of the specified type, for example adding the node \"ng\" to a process group will result in an error. Entities can be a part of several groups, and there is no limitation to the number of member sin a group.</p> Parameter Type Description type String Type of the group (node/process) entity String The name of the node or process which is to be a part of a group group String The name of the group"},{"location":"input_data/#node_diffusion","title":"node_diffusion","text":"<p>Node diffusion is used to model flow of energy between nodes with states, with the size of the flow depending on the level of the node state and the given diffusion coefficient. One possible application of this could be the flow of heat from the inside of a building to the outside during heating season. The flow of energy between nodes N1 and N2 is simply calculated as E = k (T1 - T2), with T1 and T2 being the temperatures of the nodes. If the temperature difference is negative (T2 &gt; T1), the flow of energy goes from N2 to N1, and if (T1 &gt; T2), the energy flows from N1 to N2. The temperatures of the nodes are linked to the level of the node states, either directly if the is_temp flag for the state is 1, or alternatively using the T_E_converison coefficient if the state is modelled as energy. </p> Parameter Type Description node1 String The node from which heat flows if the temperature difference T1 - T2 is positive node2 String The node to which heat flows if the temperature difference T1 - T2 is positive diff_coeff Float The diffusion coefficient between the nodes. Must be positive."},{"location":"input_data/#node_history","title":"node_history","text":"<p>When modelling delay flows between nodes in Predicer, there is a flow from one node n1 at timestep t to another node n2 at timestep t+d, where d is the length of the delay. The node_history sheet is used to define flows into node n2 for the d first timesteps of the optimization horizon, when the model cannot determine the flow from node n1, since it is outside of the optimization horizon. Node history can be seen as an inflow into a node for d timesteps. </p> <p>The node history data should be provided for all nodes that are on the recieving end of a delay relation. The data for each node is given in two columns, one with the relevant timesteps, and the other with the size of the flow. The notation for the first column is of form nodename,t,scenario and the notation for the second column is of form nodename,scenario. Below is an example from the input_data_delays.xlsx model with a delay flow ending in the dh2 node. The length of the columns don't have to be equal for different nodes.</p> t dh2,t,s1 d2,s1 1 20.4.2022 0:00 3 2 20.4.2022 1:00 4 3"},{"location":"input_data/#node_delay","title":"node_delay","text":"<p>Node delay is used to model a delay in the flow between two nodes, with a river hydropower system being a great example. When water is released from an upstream reservoir it takes a while until the water flow reaches a reservoir downstream. A delay flow is defined between two nodes with node balance, so commodity nodes or market nodes cannot be a part of a delay relation. The delay flow is one-way, with an efficiency of 1. </p> Parameter Type Description node1 String Name of the from node node2 String Name of the to node delay_ Float Delay between the nodes in hours min_flow Float Minimum allowed value for the flow max_flow Float Maximum allowed value for the flow"},{"location":"input_data/#process_topology","title":"process_topology","text":"<p>Process topologies are used to define the process flows and capacities in the modelled system. Flows are connections between nodes and processes, and are used to balance the modelled system.</p> Parameter Type Description process String Name of the process source_sink String Determines whether the connection node is a source or a sink for the process node String Name of the connection node capacity Float Capacity of the connection VOM_cost Float Variable operational and maintenance cost of using the corresponding process flow ramp_up Float Determines the hourly upward ramp rate of the corresponding process flow ramp_down Float Determines the hourly downward ramp rate of the corresponding process flow initial_load Float Sets the initial value of the process load, from which optimization starts initial_flow Float Sets the initial value of the process flow, from which optimization starts"},{"location":"input_data/#efficiencies","title":"efficiencies","text":"<p>Unit-based processes can have a flat efficiency, as defined in the processes sheet, or an efficiency which depends on the load of the process. Load-based efficiency can be defined in the sheet efficiencies. Defining an efficiency in the efficiencies sheet overrides the value given in the processes sheet. The efficiency of a process is  defined on two rows; one row for the operating point, op, and one row for the corresponding efficiency, eff.  In the example table below, the efficiency of an imaginary gas turbine gas_turb has been defined for four load intervals. The number of given operating points and corresponding efficiencies is chosen by the user, simply by adding or removing columns The operating points are defined on a row, where the first column has the value process,op, and the efficiencies are defined on a row where the value of the first column is process,eff. </p> process 1 2 3 4 gas_turb,op 0.4 0.6 0.8 1.0 gas_turb,eff 0.27 0.31 0.33 0.34"},{"location":"input_data/#reserve_type","title":"reserve_type","text":"<p>The sheet reserve_type is used to define the types of reserve used in the model, mainly differing based on reserve activation speed. </p> Parameter Type Description type String Name of the reserve type ramp_factor Float Ramp rate factor of reserve activation speed. (If reserve has to activate in 1 hour, ramp_factor is 1.0. In 15 minutes, ramp_factor is 4)"},{"location":"input_data/#markets","title":"markets","text":"<p>Markets are a type of node, with which the modelled system can be balanced by buying or selling of a product such as electricity. Markets can either be of the energy type, or of the reserve type. </p> Parameter Type Description market String Name of the market type String type of the market (energy or reserve) node String Node a market is connected to, or nodegroup a reserve market is ocnnected to. processgroup String The processgroup the reserve market is connected to. Not used for energy markets. direction String Direction of the market, only for reserve markets reserve_type String Determines the type of the reserve is_bid Bool Determines if bids can be offered to the market is_limited Bool Determines if reserve markets are limited min_bid Float Minimum reserve offer if limited max_bid Float Maximum reserve offer if limited fee Float Reserve participation fee (per time period) if limited"},{"location":"input_data/#reserve_realisation","title":"reserve_realisation","text":"<p>reserve realisation is defined for each defined reserve market separately for each defined scenario. The realisation of the reserve is the expected share of activation for the offered reserve capacity for each timestep. A value of 0.0 means that none of the offered reserve capacity is activated, and 1.0 means that 100% of the offered capacity is activated, and the corresponding energy produced by reserve processes defined by the user. The notation of the reserve_realisation sheet is as such: the reserve markets are given on rows 2:n in the first column, with the scenarios being defined on the first row from column B forward. The realisation probability is given in the intersection of the reserve markets and the scenarios. An example of the layout of the sheet is shown below. The model contains two reserve markets (res_up and res_down), and 3 scenarios (s1, s2 and s3).</p> <p>The energy imbalance caused by reserve activation is allocated to the nodes that are members in the nodegroup linked to the reserve market, defined in the markets sheet. The necessary actions to produce the reserve are taken by the members of the processgroup defined in the markets sheet.</p> reserve_products s1 s2 s3 res_up 0.3 0.2 0.3 res_down 0.1 0.2 0.4"},{"location":"input_data/#time-series-data","title":"Time series data","text":"<p>Time series are used in Predicer to represent parameters that are time-dependent. The notation to define time series data in the excel input files depend on the time series data in question. </p> <p>The sheet timeseries contains the timesteps used in the model. This sheet contains only one column t, with the given time steps.</p> <p>Example</p> t 20.4.2022 1:00 20.4.2022 2:00 20.4.2022 3:00 20.4.2022 4:00 20.4.2022 0:00 20.4.2022 5:00 20.4.2022 6:00 20.4.2022 7:00 20.4.2022 8:00 20.4.2022 9:00"},{"location":"input_data/#time-series-notation-in-the-excel-format-input-data","title":"Time series notation in the excel-format input data","text":"<p>The first column, t, should contain the time steps for the time series data. The following columns (2-n) should contain the values corresponding to the given time steps. The name of the other columns should start with the name of the linked entity, usually followed by which scenario the value is for. The values can be defined for each scenario in separate columns, or a single column can be used for several scenarios, separated by commas. The notation used for the different time series is given in the table below.</p> <p>As an example the inflow for the node nn can be given as nn,s1 if the values are given for scenario s1, and nn,s1,s2 if the given values should be for both s1 and s2. If all scenarios should have the same values, they can be defined as nn,ALL. </p> Sheet Description Notation cf Capacity factor time series for processes with cf functionality process, scenario(s) inflow Inflow time series for nodes (inflow positive value, demand negative value) node, scenario(s) price Price time series for the cost of using commodity nodes node, scenario(s) market_prices Price time series for the defined markets market, scenario(s) balance_prices Price time series for balance markets market, direction, scenario(s) fixed_ts Value time series for setting market volumes to a fixed value market eff_ts Value time series of the efficiency of processes process, scenariox(s) cap_ts Value time series limiting a flow of a process Process, connected node, scenario"},{"location":"input_data/#scenario","title":"scenario","text":"<p>The scenarios in Predicer are separate versions of the future, with potentially differing parameter values. Predicer optimizes the optimal course of action, based on the probability of the defined scenarios.</p> Parameter Type Description name String Name of the scenario probability Float Probability of the scenario. The sum of all rows should be 1"},{"location":"input_data/#risk","title":"risk","text":"<p>The risk sheet in the excel-format input data contains information about the CVaR (conditional value at risk). For details, see [1] and [2]</p> Risk parameter Description alfa Risk quantile beta Share of CVaR in objective function"},{"location":"input_data/#inflow_blocks","title":"inflow_blocks","text":"<p>Inflow blocks, or simply blocks, are potential flexibility which can be modelled with Predicer. A block has generally been thought of as \"if a demand response action is taken on time t by reducing/increasing inflow to node n by amount x, how must the system compensate on times- t-1, t-2.. or t+1, t+2...\", or \"if the heating for a building is turned off on time t, what has to be done in the following hours to compensate?\". The blocks can thus be seen as a potential for flexibility, and how the system has to be compensated as a consequence of using the potential.</p> <p>Each block consists of a binary variable, consequent timesteps, and a constant value for each timestep. Each block is linked to a specific node, as well as a specific scenario. Despite being called \"Inflow blocks\", they can be linked to nodes without any inflow as well. Node inflow is modelled for each timestep and scenario as the given value in the inflow sheet. The product of the block binary variable value and the given constant is added to the inflow for relevant combinations of node, scenario and timestep. Two active blocks cannot overlap in the same node, time and scenario. The user can define any number of blocks for the same time, but only one can be active for a specific node, scenario and timestep. </p> <p>Inflow blocks are defined in the inflow_blocks sheet. The first column of the sheet is named t, and is not used in the model itself. Each block is defined using one column for the timesteps and scenario columns for scenario based constant values. The name for the timestep column is of the form blockname, nodename and names for the scenario columns are of the form blockname, scenario. It is important, that these columns have an equal amount of rows. The columns for different blocks can have different amount of rows.</p> <p>As an example, assume there are two blocks, b1 and b2. The blocks should be defined to the inflow_blocks sheet as following:</p> t b1, n1 b1, s1 b1, s2 b2, n2 b2, s1 b2, s2 1 20.4.2022 1:00 6 4 20.4.2022 6:00 -3 -2 2 20.4.2022 2:00 -3 -2 20.4.2022 7:00 2 1 3 20.4.2022 3:00 -2 -1 20.4.2022 8:00 1 1 4 20.4.2022 4:00 -1 1 <p>As with the generic constraints described below, the validity of the user input is not checked. The user should thus ensure, that the node linked to the block can handle the change in inflow, especially in nodes with either only consumers or producer. If a block causes a change in the sign of the inflow (- to +, or + to -), the results may be unpredictable. As an example, using a block causing a positive flow of heat into a district heating node without any way to remove the heat would result in high penalty costs, and the model would thus not use the block.</p>"},{"location":"input_data/#general-constraints","title":"General constraints","text":"<p>General constraints in Predicer can be used to limit or fix process flow variables, online variables, or storage state variables in relation to other variables or a given value. The name and type of the constraint is defined in the sheet constraints, and the factors are defined in the sheet gen_constraint. </p>"},{"location":"input_data/#constraint","title":"constraint","text":"Parameter Type Description name String Name of the general constraint operator String The operator used in the general constraint. eq for =, gt for &gt; and lt for &lt; is_setpoint Bool Indicates whether the constraint is fixed, or if the model can deviate from the value. penalty Float A user-defined penalty for deviating from the givenn value, if constraint is a setpoint."},{"location":"input_data/#gen_constraint","title":"gen_constraint","text":"<p>The user can define additional constraints to the Predicer model, making it more flexible. Genral constraints are a powerful tool for customizing the model, but can also cause problems that are difficult to detect and solve. The user can either add \"rigid\" constraints, essentially defining a value or a range of values from which a variable or a sum of variables cannot deviate. Normal general constraints are applicable for flow, state and online variables. </p> <p>The user can also define so-called \"setpoint\" constraints, in which the optimizer can deviate from the values defined by the user. Deviation from the values defined in the setpoint constraints adds and additional cost to the model. The setpoint constraints are only applicable for state and flow variables, not online variables. </p> <p>The time series data in the sheet gen_constraint has a special notation. As with other time series data, the first column t in the sheet gen_constraint contains the time steps for the constraint. The rest of the columns (2-n) contain information corresponding to specific constraints, defined in the sheet constraint. </p> <p>\"rigid\" general constraints contain factors, which add up to a constant. The notation for the first row of columns (2-n) depends on the type of variable the factor refers to. For process flow variables, v_flow, the notation is constraint name, process, process flow, scenario. For process online variables, v_online, the notation is constraint name, process, scenario. For storage state variables, v_state, the notation is constraint name, node, scenario. Each constraint can also have a constant value added, with the notation constraint name, scenario for the column. For \"setpoint\" constraints, only one column of factors can be defined, as per the previously mentioned notation. </p> <p>As an example of a normal general constraint, assume a CHP gas turbine gt with a input flow of natural gas ng, as well as outputs of electricity elc and heat in the form of exhaust gases heat. Assume, that the ratio of heat and power should be 3:1, meaning an electrical efficiency of 25%, and the remaining 75% being heat. To ensure this ratio, a general constraint named gt_c1 is defined in the sheet constraint, with the operator set to eq. </p> name operator is_setpoint penalty gt_c1 eq 0 0 <p>In the sheet gen_constraint, the names of the columns referencing to the factors should be gt_c1,gt,heat,s1 and gt_c1,gt,elc,s1. This refers to the constraint gt_c1, the process gt, and the process flows heat and elc. The name of the column referencing to the constant should be gt_c1,s1. As the sum of the factors equal the constant, the value of the factors should be 3 or -3 for the factor representing the electricity flow, and -1 or 1, respectively, for the factor representing the heat flow. The value of the constant should be 0. As the sum of the factors equal the constant, it would lead to 3 * elc - 1 * heat = 0 or alternatively -3 * elc + 1 * heat = 0.</p> t gt_c1,gt,elc,s1 gt_c1,gt,heat,s1 gt_c1,s1 t1 3 -1 0 t2 3 -1 0 tn 3 -1 0 <p>As another example, assume that the operation of two online processes, proc_1 and proc_2, should be limited in regard to eachother.  Assume, that the constraint c_online is used to limit the online variables v_online of these processes so, that the processes are not operating at the same time, but that one of the two is always active. The variable v_online is a binary variable with values of 0 or 1. The sum of the online variables of proc_1 and proc_2 should be set to 1, in order to one, but not two, of the processes to be active. As the general constraint is set equal to 0, the addiotional constant should be set to -1. This ensures, that **proc_1* + proc_2 - 1 == 0*. </p> t c_online,proc_1,s1 c_online,proc_1,s1 c_online,s1 t1 1 1 -1 t2 1 1 -1 tn 1 1 -1 <p>If both the processes should be either online or offline at the same time, the coefficients for one process should be 1, and the other should be -1, weith the constant set to 0. This would result in the constraint **proc_1* - proc_2 + 0 == 0*. </p> <p>As an example of a setpoint general constraint, assume the value of the electricity, elc, production of the process gas_turb has to be between 3 and 8. To do this, two setpoint constraints are defined, c_up and c_dw, for defining an upper and lower boundary for the process flow. As above, the constraints are defined in the gen_constraint sheet. The operator for c_up should be st (= smaller than), and the operator for c_dw should be gt (=greater than). Both constraints are defined as setpoint constraints, with a deviation penalty of 100. The unit of the penalty is simply per unit of variable, meaning a variable deviation of 2 would increase the costs in the model with 200.</p> name operator is_setpoint penalty c_up st 1 100 c_dw gt 1 100 <p>In the constraint sheet, the values for the upper and lower boundaries are defined. The constraints c_up is the upper boundary, and a value of 8 is given. For c_dw, a value of 3 is defined. With these constraints, the electricity production of gas_turb has to be between 3 and 8. Any deviation from this range will result in a penalty of 100 for each unit of production exceeding this range. </p> t c_up,gas_turb,elc,s1 c_dw,gas_turb,elc,s1 t1 8 3 t2 8 3 tn 8 3"},{"location":"introduction/","title":"Overview","text":""},{"location":"introduction/#predicer","title":"Predicer","text":"<p>\u2018Predictive decider\u2019 for actors making decisions over multiple stages</p> <p>If you use Predicer in a public work, please cite the following document</p> <p>Pursiheimo, E, Sundell D., Kiviluoma J., and Hankimaa H. (2023)  \u2018Predicer: Abstract Stochastic Optimisation Model Framework for  Multi-Market Operation\u2019. Optimization and Engineering 25 (1): 253\u201382. doi:10.1007/s11081-023-09824-w</p>"},{"location":"references/","title":"References","text":""},{"location":"references/#references","title":"References","text":"<p>1. Krokhmal, P., Uryasev, S., and Palmquist, J., \u201cPortfolio optimization with conditional value-at-risk objective and constraints,\u201d J. Risk, vol. 4, no. 2, pp. 43\u201368, 2001, doi: 10.21314/jor.2002.057.</p> <p>2. Fleten, S. E. and Kristoffersen, T. K., \u201cStochastic programming for optimizing bidding strategies of a Nordic hydropower producer,\u201d Eur. J. Oper. Res., vol. 181, no. 2, pp. 916\u2013928, 2007, doi:  10.1016/j.ejor.2006.08.023 .</p>"},{"location":"references/#funding","title":"Funding","text":"<p>The development of Predicer has been partially funded in the EU Horizon ELEXIA, Business Finland HOPE and Academy of Finland EasyDR projects. - European Union ELEXIA: Demonstration of a digitized energy system integration across sectors enhancing flexibility and resilience towards efficient, sustainable, cost-optimised, affordable, secure and stable energy supply - Business Finland HOPE: Highly Optimized Energy systems - Academy of Finland EasyDR: Enabling demand response through easy to use open source approach</p> <p> </p> <p></p> This work has been partially supported by the EU project ELEXIA (2022-2026), which has received funding from the European Climate, Energy and Mobility programme under the European Union's HORIZON research and Innovation actions under grant N\u00b0101075656. <p> </p>"},{"location":"blog/","title":"Blog","text":""}]}